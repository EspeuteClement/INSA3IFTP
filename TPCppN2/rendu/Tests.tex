\documentclass[10pt]{article}

\usepackage{custom}

\title{Tests for C++ Assignment \#2}
\author{Pair B3408 \\ {\sc Renault} Benoit, {\sc Espeute} Clément}
\date{}
\usepackage[top=1in, bottom=1.25in, left=1.25in, right=1.25in]{geometry}
\usepackage{listings}
\usepackage{graphicx}
\usepackage{hyperref}

\definecolor{commentColor}{rgb}{0.7,0.7,0.7}
\definecolor{mygray}{rgb}{0.5,0.5,0.5}
\definecolor{mymauve}{rgb}{0.58,0,0.82}
\lstset{language=bash} 
\lstset{ %
  backgroundcolor=\color{black!5},   % choose the background color; you must add \usepackage{color} or \usepackage{xcolor}
  basicstyle=\footnotesize\ttfamily,        % the size of the fonts that are used for the code
  breakatwhitespace=false,         % sets if automatic breaks should only happen at whitespace
  breaklines=true,                 % sets automatic line breaking
  captionpos=b,                    % sets the caption-position to bottom
  commentstyle=\color{commentColor},    % comment style
  deletekeywords={...},            % if you want to delete keywords from the given language
  escapeinside={\%*}{*)},          % if you want to add LaTeX within your code
  extendedchars=true,              % lets you use non-ASCII characters; for 8-bits encodings only, does not work with UTF-8
  frame=single,	                   % adds a frame around the code
  keepspaces=true,                 % keeps spaces in text, useful for keeping indentation of code (possibly needs columns=flexible)
  keywordstyle=\color{blue},       % keyword style
  language=C++,                 % the language of the code
  otherkeywords={*,...},            % if you want to add more keywords to the set
  numbers=left,                    % where to put the line-numbers; possible values are (none, left, right)
  numbersep=5pt,                   % how far the line-numbers are from the code
  numberstyle=\tiny\color{mygray}, % the style that is used for the line-numbers
  rulecolor=\color{black!20},         % if not set, the frame-color may be changed on line-breaks within not-black text (e.g. comments (green here))
  showspaces=false,                % show spaces everywhere adding particular underscores; it overrides 'showstringspaces'
  showstringspaces=false,          % underline spaces within strings only
  showtabs=false,                  % show tabs within strings adding particular underscores
  stepnumber=1,                    % the step between two line-numbers. If it's 1, each line will be numbered
  stringstyle=\color{mymauve},     % string literal style
  tabsize=2,	                   % sets default tabsize to 2 spaces
  title=\lstname,                   % show the filename of files included with \lstinputlisting; also try caption instead of title
  postbreak=\raisebox{0ex}[0ex][0ex]{\tt\color{red}-> }
}
\begin{document}
\pagestyle{fancy}
\maketitle

\section{Early Visual Tests}
During the prototyping phase of the BinaryTree, we quickly realised that we needed to have a tool that allowed us to display a graphical representation of the BinaryTree. More precisely, we needed that so we could easely see if the tree was balanced with a quick glance. Because of our lack of knowledge of the C++ libraries, we chose to create an external tool with a framework we knew how to use.

We created a Lua application that used the LÖVE2d framework. It's normally intended as a set of libraries for 2d videogame making, so it had all the tools we needed to display graphical info on the screen.

In order to pass the information from the application to the utility we created, we made a serializing method for the BinaryTree to make it into a Lua table (an associative array capable of storing many types of data, including other tables). The serialization was done recursively on the BinaryTree's Nodes, and can be found in the \texttt{Node::Serialize()} method.

Once the data was serialized, it was just a matter of loading that data into the Lua program and display that data on the screen.

\subsection*{Using the tool}
If you wish to try the tool out, you'll need to install the \texttt{love} and \texttt{lua} packages on a Gnu/Linux machine, and then run the following command : \texttt{love~utils/dispTree/} from the project root. Unfortunately, reading the data from the program is now a bit tricky because we have implemented a proper I/O interface. Because of that, you can't export the BinaryTree anymore unless you modify the main() function. As we said earlier, that tool was mostly used when creating the BinaryTree and wasn't much needed in the later development of the application when proper regression tests were implemented.

\section{<TestEngine> Class}
The <TestEngine> class contains static functions meant to test the different core classes of the application. These were used really often used during the development to ensure modifications to the data structures did not cause any unforeseen behaviour.

Especially, because the visualisation tool wasn't meant to find small imperfections in the tree, we had to implement some automatics tests in order to see if the tree's balance met all the requirements of a self-balancing binary search tree (abb. "AVL tree"). We created two tests designed to find those small flaws. Because those tests works using the internals features of the programs, they needed to be put in the code. Thus we created the TestEngine class. This class only uses static methods, with each method corresponding to a different test.

\subsection{\tt TestEngine::Iteration\_Test1()}
This test is designed to check if the Iteration method visited all the Nodes in the tree exactly once. A boolean array is created that keeps in memory which Nodes are visited. Then we create and fill the BinaryTree, and then iterate through it. The function will return a true boolean value if all the Nodes are indeed visited only once. If an error is found, a message will appear in the console.

\subsection{\tt TestEngine::BalanceTest\_1()}
This test is designed to see if the BinaryTree is balanced after a long series of random insertions. It create and fills a BinaryTree with random sensors ID, and then iterate through all the Node, checking the balance of every Node and prompting an error if a balance of 2 or more is found (indicating that we don't fill the AVL tree requirements.

\subsection{\tt static bool SearchTest\_1()}
Almost an exact copy of the Iteration Test. The difference is that it just creates the Nodes in the tree and sees if the Search Node function works on all the IDs.

\subsection{\tt TestEngine::SensorTest\_1()}
This test checks if the basic functionnalities of Sensor are working. Simply put, it creates a single Sensor object, adds events to it, and displays statistics about the sensor. It returns a boolean value of true if the test is successful, false else.

\section{External tests}
Those tests were created in order to see if our application was properly functioning according to the inputs/outputs described in the assignement. We used the \texttt{test.sh} file provided with some in and out files also provided in order to see if the basic functions were properly functioning (that is, passing them into the program, and automatically checking the results it provided). We also used a 20 000 000 instructions long file provided by another group that allowed us to see if our program was performing well under the worst case scenario for the TP.

Finally, we needed to test the optional instruction, being \texttt{OPT}, for which no test files were provided. For that, we wrote a simple lua script : (\texttt{generateValues.lua} in the \texttt{tests/} folder) that generated the in and out files for this test. The program chooses a random minute between 2 given hours as the "optimal" path. Then it writes into the .in file ADD commands filling all the minutes between the 2 hours with "R" traffic except for the chosen minute where the traffic is "V". Multiples Sensors are created in the same way, but with the "V" traffic put so the chosen path will be fully composed of "V" traffix states.

At the end, the program writes in the .out file the expected output.

This allowed us to see if the program behaved as expected.

\section{Other tests}
We used the {\tt valgrind} command to see if we had any memory leaks and errors. That allowed to track some hidden flaws in our programs and help optimizing it (by reducing our use of objects).
\end{document}