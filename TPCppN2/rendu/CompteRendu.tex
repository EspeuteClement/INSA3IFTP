\documentclass[10pt]{article}

\usepackage{custom}

\title{Report Assignment C++ \#2}
\author{Pair B3408 \\ {\sc Renault} Benoit, {\sc Espeute} Clément}
\date{}
\usepackage[top=1in, bottom=1.25in, left=1.25in, right=1.25in]{geometry}
\usepackage{listings}
\usepackage{graphicx}
\usepackage{hyperref}

\definecolor{commentColor}{rgb}{0.7,0.7,0.7}
\definecolor{mygray}{rgb}{0.5,0.5,0.5}
\definecolor{mymauve}{rgb}{0.58,0,0.82}
\lstset{language=bash} 
\lstset{ %
  backgroundcolor=\color{black!5},   % choose the background color; you must add \usepackage{color} or \usepackage{xcolor}
  basicstyle=\footnotesize\ttfamily,        % the size of the fonts that are used for the code
  breakatwhitespace=false,         % sets if automatic breaks should only happen at whitespace
  breaklines=true,                 % sets automatic line breaking
  captionpos=b,                    % sets the caption-position to bottom
  commentstyle=\color{commentColor},    % comment style
  deletekeywords={...},            % if you want to delete keywords from the given language
  escapeinside={\%*}{*)},          % if you want to add LaTeX within your code
  extendedchars=true,              % lets you use non-ASCII characters; for 8-bits encodings only, does not work with UTF-8
  frame=single,	                   % adds a frame around the code
  keepspaces=true,                 % keeps spaces in text, useful for keeping indentation of code (possibly needs columns=flexible)
  keywordstyle=\color{blue},       % keyword style
  language=C++,                 % the language of the code
  otherkeywords={*,...},            % if you want to add more keywords to the set
  numbers=left,                    % where to put the line-numbers; possible values are (none, left, right)
  numbersep=5pt,                   % how far the line-numbers are from the code
  numberstyle=\tiny\color{mygray}, % the style that is used for the line-numbers
  rulecolor=\color{black!20},         % if not set, the frame-color may be changed on line-breaks within not-black text (e.g. comments (green here))
  showspaces=false,                % show spaces everywhere adding particular underscores; it overrides 'showstringspaces'
  showstringspaces=false,          % underline spaces within strings only
  showtabs=false,                  % show tabs within strings adding particular underscores
  stepnumber=1,                    % the step between two line-numbers. If it's 1, each line will be numbered
  stringstyle=\color{mymauve},     % string literal style
  tabsize=2,	                   % sets default tabsize to 2 spaces
  title=\lstname,                   % show the filename of files included with \lstinputlisting; also try caption instead of title
  postbreak=\raisebox{0ex}[0ex][0ex]{\tt\color{red}-> }
}

\begin{document}
\pagestyle{fancy}
\maketitle
\section{<Sensor> class specifications}
\subsection{Global presentation}
Stores the ID of a given sensor and a pointer to a tri-dimensional index of Stats event counters thus allowing easy computation of statistics on a per minute, hour, day and sensor basis.

\subsection{Structures overview}
\subsubsection*{Structure <Stats>}
Stores event integer counters for each of the possible traffic states (v, j, r, n).

\paragraph{Constructor :}
Default constructor sets all array elements to zero.

\paragraph{Overload of operator+= :}
Allows adding two Stats structs by adding each array element separately.

\paragraph{Sum method :}
Adds the statistics of the struct instance together.

\subsubsection*{Structure <StatsRel>}
Stores relative statistics for each of the possible traffic states (v, j, r, n).

\paragraph{Constructor :}
Default constructor converts all the attributes of the passed in Stats struct into statistics relative to the sum of all the counters.

\paragraph{PrintStatsRel :}
Displays the attributes of the StatsRel struct one per line, rounded into percentages.

\subsection{Functions overview}

\subsubsection*{Constructor}
Default constructor sets ID to the one given and dynamically allocates the memory required for the tri-dimensional index.st

\subsubsection*{AddEvent}
Increments the suitable event state counter for a given day of week, hour and minute by one.

\subsubsection*{GetStatsByMin}
Getter for the Stats of a given time.

\subsubsection*{AddStatsByDay}
Adds all the Stats structs comprised in the given day to the Stats struct which pointer is passed in.

\subsubsection*{AddStatsByHour}
Adds all the Stats structs comprised in the given day and hour to the Stats struct which pointer is passed in.

\subsubsection*{AddStatsBySensor}
Adds all the Stats structs of the current Sensor to the Stats struct which pointer is passed.

\subsubsection*{GetDuration}
Computes and returns the probable duration of the journey through the road segment associated with the sensor. Each probable state is associated with a duration : (v$\to$1, j$\to$2, r$\to$4, n$\to$10). If no data if available, all the stats are equal to zero, therefore affecting 1 minute ("v" case).

\subsubsection*{GetID}
Getter for the sensor ID.

\subsubsection*{PrintSensorStatsRel}
Computes and displays the statistics of the current Sensor for every attribute (v, j, r, n).

\section{<IoEngine> class specifications}
\subsection{Global presentation}
Manages the inputs on the standard input stream and displays the according data. For details about the commands format or meaning, please directly refer either to the assignement or the documentation of the class.

\subsection{Functions overview}

\subsubsection*{Constructor}
Default constructor affects the BinaryTree pointer to the attribute.

\subsubsection*{ReadInput}
Reads the input from the STDIO and modify the tree if needed.

\subsubsection*{HandleADD}
Calls the necessary function thats adds the new event to the appropriate sensor and creates the sensor (and the associated node in the binary tree) if they don't exist yet.

\subsubsection*{HandleJAM\_DH}
Performs the JAM\_DH operation : computes and displays the percentage of traffic jam (corresponding to a "r" or "n" traffic state) for each hour (0 to 23) of a given day of the week, averaging from every sensor.

\subsubsection*{HandleOPT}
Performs the OPT operation : computes and displays the optimal time (which reduces the duration of the journey through the given segments) of departure and the associated minimal duration. It is assumed that every required sensor exists or the function will simply exit.

\subsubsection*{HandleSTATS\_C}
Performs the STATS\_C operation : displays the statistics for each of the traffic states attributes (v, j, r, n) of a sensor as percentages, one by line. It is assumed the sensor exists or the function will simply exit.

\subsubsection*{HandleSTATS\_D7}
Performs the STATS\_D7 operation : computes and displays the statistics of every traffic state (v, j, r, n) of a given day of the week, averaging from every sensor.

\section{Storing the Sensors}

We chose to use a BinaryTree to store the Sensors. It allows us to have a very fast indexing and insertion speed.
Here are some explanations about the vocabulary that we will use later :

\begin{description}
	\item[Node] Represents an element in our tree. Each node has two children and one parent and contains a pointer to a Sensor. The Sensor's ID determines the position of the node in the tree, as the left child Sensor's ID is always lower than the one of it's parents, and the right one is higher.
	\item[Height] The height is defined as the longest chain of nodes in a subtree.
	\item[Balance] The balance of a node is determined like this : $ leftSubtreeHeight - rightSubtreeHeight$. It allows to know if a subtree is balanced or not. In our tree, the node balance has to be between $-1$ and $+1$. If it is higher/lower, we have to perform some balancing operations.
\end{description}

\section{<Node> Class Specifications}
\subsection{Global Presentation}
Node is a class that represents a BinaryTree element. Again, each node contains a Sensor pointer and three Node pointers : one for the parent node and two for the left and right child nodes. The nodes are sorted with the Sensor ID : Nodes that are at the left of this node will have their Sensor ID lower to this one, and Node to the left will have a Sensor ID higher to this one.

\subsection{Function overview}
\subsubsection*{\tt Node(Sensor *sensor, Node *parent, Node *left, Node *right)}
By default, the node constructor only take a pointer to a Sensor as an argument. You can also specify pointers to the \emph{parents} Node and the children \emph{left} and \emph{right} nodes (defaulted to NULL).
\subsubsection*{\tt Node *GetLeft()  and Node *GetRight() }
Simple Getters for the left and ligth childs of this node.

\subsubsection*{\tt long GetHeight()}
Return the height (as a long) of the subtree.

\subsubsection*{\tt long GetBalance()}
Return the balance (as a long) of this subtree.

\subsubsection*{\tt Node *Search(long searchID)}
Search and return a Node with a sensor that has the same ID as searchID in this subtree. If the node hasn't been found, will return a NULL pointer instead.
The node works as the tree's root for this search. This function use recursive implementation : If this Node's Sensor ID doesn't match \emph{searchID}, we call Search again on the left of right child of the node depending if \emph{searchID} is lesser or greater than the Node Sensor ID. If the ID match, we simply return the pointer to the current Node, and if we can't go further in the tree (because there are NULL pointers) we return NULL. 

\subsubsection*{\tt Node *Insert(int searchID)}
Insert will return the node with the right ID (matching searchID) in the tree, or create a new one and return it if the ID hasn't been found. It's mainly used by the BinaryTree::Insert method, as this method will always return a valid Node.
This implementation almost identical to Search, expect that when we find a NULL pointer (meaning that our sensor is missing from the tree), we insert a New node to fill the hole, and then we call Rebalance (private method of Node) so

\subsubsection*{\tt Sensor *GetSensor()}
Simple getter for the Sensor. Return a pointer to the Node's Sensor.

\section{<BinaryTree> Class Specifications}
\subsection{Global Presentation}
While Node can act by itself has a binary tree, the BinaryTree class offers a useful layer of functions that can be used to manipulate the tree. It keeps track of the root (the first node in the tree), allow to iterate thought the Tree. It also allows to add data in a specific Sensor in one command.

\subsection{Function Overview}
\subsubsection*{\tt Sensor *Search(long ID)}
Simply return a pointer to the Sensor with the ID matching \emph{ID}. Will return NULL if that sensor hasn't been found.

\subsubsection*{\tt void Insert(int ID, 
				unsigned char d,
				unsigned char h,
				unsigned char m,
				char value)}

Allows to put data from the "ADD" in the sensor with the right \texttt{ID}. \texttt d correspond to the day in the d7 format, \texttt h and \texttt m corresponds to the hours and minutes respectively. Because this methods calls {\tt Node *Insert(int searchID)}, we are assured that our Sensor will be in the tree (because it will be created if he doesn't exists).

\subsubsection*{\tt Node *GetRoot()}
Returns the root Node of the subtree as a pointer to this Node.

\subsection{Iterating trough the tree}
The process of iterating trough the tree is fairly simple. Each time we call Iterate(), we get a pointer to a node in the tree that we haven’t visited yet, until we get a null pointer, indicating that we have traversed the tree. Using InitIterate allows to initialize the variables so the Iteration can run smoothly.

We keep track of our position in the tree via a Stack containing the path from the current node to the tree's root. The stack is just an pointer array with a variable keeping the current number of pointers in the array.

For iterating, We start from the root, and we will return the current node at the end of the method. But before that, we will push the next node to visit in the stack. We prioritize the left nodes, then the right ones. If we can't go down the tree any more (only NULL pointers), we pop nodes in the stack until we can go right again.

\subsubsection*{InitIterate}
Prepare the Tree for a iteration trough the tree. It initialize the stack using the height of the tree.

\subsubsection*{\tt Node *Iterate()}
Will return a pointer to a Node that hasn't been visited yet, or NULL if we reached the end of the tree.

\section{<IoEngine> class specifications}
\subsection{Global presentation}
Manages the user inputs on the standard input stream that are described in the assignment and displays the according data. For that, it is assigned as an attribute the pointer to the BinaryTree used to store the Sensors. For details about the commands format or meaning, please directly refer either to the assignement or the documentation of the class.

\subsection{Functions overview}

\subsubsection*{Constructor}
The default constructor affects the passed in BinaryTree pointer to the attribute.

\subsubsection*{ReadInput}
Reads the input from the standard input stream and calls for the methods associated to the user commands. Returns a boolean value of false if the command 'EXIT' has been issued, true otherwise.

\subsubsection*{HandleADD}
Reads the details of the ADD command and calls the necessary function thats adds the new event to the appropriate sensor and creates the sensor (and the associated node in the binary tree) if they don't exist yet\footnote{ If the command is valid (respects the assignment format)}.

\subsubsection*{HandleJAM\_DH}
Performs the JAM\_DH operation : computes and displays the percentage of traffic jam (corresponding to a 'R' or 'N' traffic state) for each hour of a given day of the week, averaging from every sensor\footnotemark[2].

\subsubsection*{HandleOPT}
Performs the OPT operation : computes and displays the optimal time (which reduces the duration of the journey through the given segments) of departure and the associated minimal duration of the journey\footnotemark[2]'\footnote{ It is assumed that every required sensor exists or the method will simply exit.}. As it calls for the GetDuration function, same consequences apply if Sensor data is missing for given time.

\subsubsection*{HandleSTATS\_C}
Performs the STATS\_C operation : displays the statistics for each of the traffic states attributes ('V', 'J', 'R', or 'N') of a sensor as percentages, one by line, according to the assignement\footnotemark[2]'\footnotemark[3].

\subsubsection*{HandleSTATS\_D7}
Performs the STATS\_D7 operation : computes and displays the statistics of every traffic state ('V', 'J', 'R', or 'N') of a given day of the week, averaging from every sensor\footnotemark[2].

\section{<Main> class specifications}
Last, but not least, this class contains the entry point of the program. In this entry point function, the BinaryTree which will contain all the Sensors is created, and then passed in to the IoEngine, which will then loop until the user issues the 'EXIT' command. Before ending, the program will display the time used to perform in seconds.
If in debug mode, (\texttt{\#define DEBUG}), this function will rather execute the tests described in the dedicated report.

\end{document}